type VotePlusUser = 
 record {
   userEmailId: text;
   userModClubId: principal;
   userUserName: text;
   userVoteCreatedAt: int;
   userVoteDecision: Decision__1;
 };
type VoteParamsId = text;
type VoteParameters = 
 record {
   complexity: Complexity;
   createdAt: Timestamp;
   id: VoteParamsId;
   requiredVotes: int;
   updatedAt: Timestamp;
 };
type VoteId = text;
type Vote = 
 record {
   contentId: text;
   createdAt: Timestamp;
   decision: Decision;
   id: VoteId;
   userId: UserId;
   violatedRules: opt vec RuleId;
 };
type ViolatedRules__1 = 
 record {
   ruleDesc: text;
   ruleId: text;
 };
type ViolatedRules = 
 record {
   id: RuleId;
   rejectionCount: nat;
 };
type VerifyHumanityResponse = 
 record {
   rejectionReasons: vec text;
   status: PohVerificationStatus;
   token: opt text;
 };
type UserId = principal;
type UpdateCallsAggregatedData = vec nat64;
type TxIndex = nat;
type Trie_3 = 
 variant {
   branch: Branch_3;
   "empty";
   leaf: Leaf_3;
 };
type Trie_2 = 
 variant {
   branch: Branch_2;
   "empty";
   leaf: Leaf_2;
 };
type Trie_1 = 
 variant {
   branch: Branch_1;
   "empty";
   leaf: Leaf_1;
 };
type Trie2D_1 = 
 variant {
   branch: Branch_2;
   "empty";
   leaf: Leaf_2;
 };
type Trie2D = 
 variant {
   branch: Branch;
   "empty";
   leaf: Leaf;
 };
type Trie = 
 variant {
   branch: Branch;
   "empty";
   leaf: Leaf;
 };
type TransformArgs = 
 record {
   context: blob;
   response: CanisterHttpResponsePayload;
 };
type Tokens = nat;
type Token = record {};
type Timestamp = int;
type SubscribePohMessage = record {
                             callback:
                              func (PohVerificationResponsePlus) -> () oneway;
                           };
type SubscribeMessage = record {callback: func (ContentResult) -> () oneway;};
type StreamingStrategy = variant {
                           Callback:
                            record {
                              callback:
                               func (Token) ->
                                (StreamingCallbackHttpResponse);
                              token: Token;
                            };};
type StreamingCallbackHttpResponse = 
 record {
   body: blob;
   token: Token;
 };
type RuleId = text;
type Rule = 
 record {
   description: text;
   id: RuleId;
 };
type Role = 
 variant {
   admin;
   moderator;
   owner;
 };
type Result_6 = 
 variant {
   err: text;
   ok: CanClaimLockedResponse;
 };
type Result_5 = 
 variant {
   err: text;
   ok: bool;
 };
type Result_4 = 
 variant {
   err: PohError;
   ok: PohTaskDataWrapperPlus;
 };
type Result_3 = 
 variant {
   err: PohError;
   ok: PohTaskDataAndVotesWrapperPlus;
 };
type Result_2 = 
 variant {
   err: text;
   ok: Reserved;
 };
type Result_1 = 
 variant {
   err: PohError;
   ok: vec PohChallengesAttempt;
 };
type Result = 
 variant {
   err: text;
   ok: TxIndex;
 };
type ReservedId = text;
type Reserved = 
 record {
   createdAt: Timestamp;
   id: ReservedId;
   profileId: text;
   reservedExpiryTime: Timestamp;
   updatedAt: Timestamp;
 };
type RelShared_1 = record {forw: Trie2D_1;};
type RelShared = record {forw: Trie2D;};
type ReceiptId = text;
type Receipt = 
 record {
   cost: int;
   createdAt: Timestamp;
   id: ReceiptId;
 };
type ProviderSettings = 
 record {
   minStaked: nat;
   requiredVotes: nat;
 };
type ProviderSettingResult = 
 variant {
   err: ProviderError;
   ok: ProviderSettings;
 };
type ProviderResult = 
 variant {
   err: ProviderError;
   ok;
 };
type ProviderPlus = 
 record {
   activeCount: nat;
   contentCount: nat;
   createdAt: Timestamp;
   description: text;
   id: principal;
   image: opt Image;
   name: text;
   rewardsSpent: nat;
   rules: vec Rule;
   settings: ProviderSettings;
   updatedAt: Timestamp;
 };
type ProviderMetaResult = 
 variant {
   err: ProviderError;
   ok: ProviderMeta;
 };
type ProviderMeta = 
 record {
   description: text;
   name: text;
 };
type ProviderInfo = 
 record {
   createdAt: Timestamp;
   description: text;
   id: principal;
   image: opt Image;
   name: text;
   updatedAt: Timestamp;
 };
type ProviderId = principal;
type ProviderError = 
 variant {
   InvalidContentStatus;
   InvalidContentType;
   InvalidProvider;
   NotFound;
   ProviderAdminIsAlreadyRegistered;
   ProviderIsRegistered;
   RequiresWhitelisting;
   Unauthorized;
 };
type ProviderAdmins = 
 record {
   admins: vec ProfileStable;
   pid: principal;
 };
type ProfileStable = 
 record {
   createdAt: Timestamp;
   email: text;
   id: UserId;
   pic: opt Image;
   role: Role;
   subaccounts: vec record {
                      text;
                      blob;
                    };
   updatedAt: Timestamp;
   userName: text;
 };
type PohVerificationStatus = 
 variant {
   expired;
   notSubmitted;
   pending;
   rejected;
   startPoh;
   verified;
 };
type PohVerificationResponsePlus = 
 record {
   challenges: vec ChallengeResponse;
   completedAt: opt int;
   isFirstAssociation: bool;
   providerId: principal;
   providerUserId: text;
   rejectionReasons: vec text;
   requestedAt: opt int;
   status: PohVerificationStatus;
   submittedAt: opt int;
   token: opt text;
 };
type PohTaskPlusForAdmin = 
 record {
   completedOn: int;
   packageId: text;
   pohTaskData: vec PohTaskData;
   profileImageUrlSuffix: opt text;
   status: ContentStatus;
   submittedAt: int;
   userEmailId: text;
   userModClubId: text;
   userUserName: text;
   voteCount: nat;
 };
type PohTaskPlus = 
 record {
   createdAt: int;
   hasVoted: opt bool;
   minStake: int;
   packageId: text;
   profileImageUrlSuffix: opt text;
   requiredVotes: int;
   reward: float64;
   status: ContentStatus;
   title: opt text;
   updatedAt: int;
   voteCount: nat;
 };
type PohTaskDataWrapperPlus = 
 record {
   createdAt: int;
   minStake: int;
   packageId: text;
   pohTaskData: vec PohTaskData;
   requiredVotes: int;
   reward: float64;
   updatedAt: int;
   votes: nat;
 };
type PohTaskDataAndVotesWrapperPlus = 
 record {
   createdAt: int;
   minStake: int;
   packageId: text;
   pohTaskData: vec PohTaskData;
   requiredVotes: int;
   reward: float64;
   updatedAt: int;
   voteUserDetails: vec VotePlusUser;
 };
type PohTaskData = 
 record {
   allowedViolationRules: vec ViolatedRules__1;
   challengeId: text;
   challengeType: PohChallengeType;
   completedOn: int;
   contentId: opt text;
   createdAt: int;
   dataCanisterId: opt principal;
   status: PohChallengeStatus;
   submittedAt: int;
   updatedAt: int;
   userId: principal;
   wordList: opt vec text;
 };
type PohStableState = 
 record {
   callbackIssuedByProvider:
    vec record {
          principal;
          vec record {
                principal;
                int;
              };
        };
   pohChallengePackages: vec record {
                               text;
                               PohChallengePackage;
                             };
   pohChallenges: vec record {
                        text;
                        PohChallenges;
                      };
   pohUserChallengeAttempts:
    vec record {
          principal;
          vec record {
                text;
                vec PohChallengesAttemptV1;
              };
        };
   providerUserIdToModclubUserIdByProviderId:
    vec record {
          principal;
          RelShared;
        };
   providersCallback: vec record {
                            principal;
                            SubscribePohMessage;
                          };
   token2ProviderAndUserData: vec record {
                                    text;
                                    PohProviderAndUserData;
                                  };
   userToPohChallengePackageId: RelShared_1;
   wordList: vec text;
 };
type PohRulesViolated = 
 record {
   challengeId: text;
   ruleId: text;
 };
type PohProviderAndUserData = 
 record {
   generatedAt: int;
   providerId: principal;
   providerUserId: text;
   token: text;
 };
type PohError = 
 variant {
   attemptToAssociateMultipleModclubAccounts: principal;
   attemptToCreateMultipleWalletsWithSameIp;
   challengeNotPendingForSubmission;
   invalidPackageId;
   invalidToken;
   pohCallbackNotRegistered;
   pohNotConfiguredForProvider;
 };
type PohChallengesAttemptV1 = 
 record {
   attemptId: opt text;
   challengeDescription: text;
   challengeId: text;
   challengeName: text;
   challengeType: PohChallengeType;
   completedOn: int;
   createdAt: int;
   dataCanisterId: opt principal;
   status: PohChallengeStatus;
   submittedAt: int;
   updatedAt: int;
   userId: principal;
   wordList: opt vec text;
 };
type PohChallengesAttempt = 
 record {
   attemptId: opt text;
   challengeDescription: text;
   challengeId: text;
   challengeName: text;
   challengeType: PohChallengeType;
   completedOn: int;
   createdAt: int;
   dataCanisterId: opt principal;
   status: PohChallengeStatus;
   updatedAt: int;
   userId: principal;
   wordList: opt vec text;
 };
type PohChallenges = 
 record {
   allowedViolationRules: vec ViolatedRules__1;
   challengeDescription: text;
   challengeId: text;
   challengeName: text;
   challengeType: PohChallengeType;
   createdAt: int;
   dependentChallengeId: opt vec text;
   requiredField: PohChallengeRequiredField;
   updatedAt: int;
 };
type PohChallengeType = 
 variant {
   dl;
   email;
   fullName;
   selfPic;
   selfVideo;
   ssn;
   userName;
 };
type PohChallengeSubmissionStatus = 
 variant {
   alreadyApproved;
   alreadyRejected;
   alreadySubmitted;
   incorrectChallenge;
   inputDataMissing;
   notPendingForSubmission;
   ok;
   submissionDataLimitExceeded;
 };
type PohChallengeSubmissionResponse = 
 record {
   challengeId: text;
   submissionStatus: PohChallengeSubmissionStatus;
 };
type PohChallengeSubmissionRequest = 
 record {
   challengeDataBlob: opt blob;
   challengeId: text;
   dataSize: nat;
   mimeType: text;
   numOfChunks: nat;
   offset: nat;
 };
type PohChallengeStatus = 
 variant {
   expired;
   notSubmitted;
   pending;
   rejected;
   verified;
 };
type PohChallengeRequiredField = 
 variant {
   imageBlob;
   profileFieldBlobs;
   textBlob;
   videoBlob;
 };
type PohChallengePackage = 
 record {
   challengeIds: vec text;
   createdAt: int;
   id: text;
   title: opt text;
   updatedAt: int;
   userId: principal;
 };
type OldModeratorLeaderboard = 
 record {
   completedVoteCount: int;
   id: UserId;
   lastVoted: opt Timestamp;
   performance: float64;
   rewardsEarned: int;
   userName: text;
 };
type NumericEntity = 
 record {
   avg: nat64;
   first: nat64;
   last: nat64;
   max: nat64;
   min: nat64;
 };
type Nanos = nat64;
type ModeratorLeaderboard = 
 record {
   completedVoteCount: int;
   id: UserId;
   lastVoted: opt Timestamp;
   performance: float64;
   rewardsEarned: int;
   rs: float64;
   userName: text;
 };
type ModClub = 
 service {
   AdminCheckPohVerificationResp: (text, principal) ->
    (PohVerificationResponsePlus);
   addProviderAdmin: (principal, text, opt principal) -> (ProviderResult);
   addRules: (vec text, opt principal) -> ();
   addToAllowList: (principal) -> ();
   addToApprovedUser: (principal) -> ();
   adminInit: () -> ();
   adminUpdateEmail: (principal, text) -> (ProfileStable);
   canClaimLockedReward: (opt Tokens) -> (Result_6);
   canReserveContent: (text) -> (Result_5);
   checkIfUserOptToReciveAlerts: () -> (bool) query;
   claimLockedReward: (Tokens, opt principal) -> (Result_5);
   collectCanisterMetrics: () -> ();
   configurePohForProvider: (principal, vec text, nat, bool) -> ();
   deregisterProvider: () -> (text);
   editProviderAdmin: (principal, principal, text) -> (ProviderResult);
   generateSigningKey: () -> ();
   getActivity: (bool) -> (vec Activity) query;
   getAdminProviderIDs: () -> (vec principal) query;
   getAllContent: (ContentStatus) -> (vec ContentPlus);
   getAllDataCanisterIds: () -> (vec principal, vec text);
   getAllPohTasksForAdminUsers: (ContentStatus, nat, nat, vec text, int,
    int) -> (vec PohTaskPlusForAdmin) query;
   getAllProfiles: () -> (vec ProfileStable) query;
   getAllUsersWantToReceiveAlerts: () -> (vec text) query;
   getCanisterLog: (opt CanisterLogRequest) ->
    (opt CanisterLogResponse) query;
   getCanisterMetrics: (GetMetricsParameters) -> (opt CanisterMetrics) query;
   getContent: (text) -> (opt ContentPlus);
   getContentResult: (text) -> (ContentResult);
   getDeployer: () -> (principal) query;
   getModeratorEmailsForPOHAndSendEmail: (text) -> ();
   getModeratorLeaderboard: (nat, nat) -> (vec ModeratorLeaderboard);
   getPohAttempts: () -> (PohStableState);
   getPohTaskData: (text) -> (Result_4) query;
   getPohTaskDataForAdminUsers: (text) -> (Result_3) query;
   getPohTasks: (ContentStatus, nat, nat) -> (vec PohTaskPlus) query;
   getProfile: () -> (ProfileStable) query;
   getProfileById: (principal) -> (ProfileStable) query;
   getProvider: (principal) -> (ProviderPlus);
   getProviderAdmins: (principal) -> (vec ProfileStable);
   getProviderContent: (principal, ContentStatus, nat, nat) ->
    (vec ContentPlus);
   getProviderRules: () -> (vec Rule) query;
   getReservedByContentId: (text) -> (Result_2);
   getRules: (principal) -> (vec Rule) query;
   getTaskStats: (int) -> (nat, nat, nat, nat);
   getTasks: (nat, nat, bool) -> (vec ContentPlus);
   getVotePerformance: () -> (float64) query;
   handleSubscription: (ConsumerPayload) -> ();
   http_request: (HttpRequest) -> (HttpResponse) query;
   http_request_update: (HttpRequest) -> (HttpResponse);
   importAccounts: (AccountsImportPayload) -> (record {status: bool;});
   issueJwt: () -> (text);
   pohCallbackForModclub: (PohVerificationResponsePlus) -> () oneway;
   populateChallenges: () -> ();
   providerSaBalance: (text, opt principal) -> (Tokens);
   registerModerator: (text, opt text, opt Image) -> (ProfileStable);
   registerProvider: (text, text, opt Image) -> (text);
   registerUserToReceiveAlerts: (principal, bool) -> (bool);
   removeProviderAdmin: (principal, principal) -> (ProviderResult);
   removeRules: (vec RuleId, opt principal) -> ();
   reserveContent: (text) -> ();
   resetUserChallengeAttempt: (text) -> (Result_1);
   retiredDataCanisterIdForWriting: (text) -> () oneway;
   retrieveChallengesForUser: (text) -> (Result_1);
   sendVerificationEmail: (text) -> (bool);
   setLambdaToken: (text) -> ();
   setRandomization: (bool) -> ();
   setVoteParamsForLevel: (int, Level) -> ();
   showAdmins: () -> (vec principal) query;
   shuffleContent: () -> ();
   shufflePohContent: () -> ();
   submitChallengeData: (PohChallengeSubmissionRequest) ->
    (PohChallengeSubmissionResponse);
   submitHtmlContent: (text, text, opt text) -> (text);
   submitImage: (text, vec nat8, text, opt text) -> (text);
   submitText: (text, text, opt text) -> (text);
   subscribe: (SubscribeMessage) -> ();
   subscribePohCallback: (SubscribePohMessage) -> ();
   toggleAllowSubmission: (bool) -> ();
   topUpProviderReserve: (record {
                            amount: nat;
                            providerId: opt principal;
                          }) -> ();
   transform: (TransformArgs) -> (CanisterHttpResponsePayload) query;
   unStakeTokens: (nat) -> (text);
   updateProvider: (principal, ProviderMeta) -> (ProviderMetaResult);
   updateProviderLogo: (principal, vec nat8, text) -> (text);
   updateRules: (vec Rule, opt principal) -> ();
   updateSettings: (principal, ProviderSettings) -> (ProviderSettingResult);
   verifyHumanity: (text) -> (PohVerificationResponsePlus);
   verifyUserHumanityForModclub: () -> (VerifyHumanityResponse);
   vote: (ContentId, Decision, opt vec RuleId) -> (text);
   votePohContent: (text, Decision, vec PohRulesViolated) -> ();
   whoami: () -> (principal);
   withdrawModeratorReward: (Tokens, opt principal) -> (Result);
 };
type MetricsGranularity = 
 variant {
   daily;
   hourly;
 };
type LogMessagesData = 
 record {
   message: text;
   timeNanos: Nanos;
 };
type List_3 = 
 opt record {
       record {
         Key_1;
         Trie_3;
       };
       List_3;
     };
type List_2 = 
 opt record {
       record {
         Key;
         null;
       };
       List_2;
     };
type List_1 = 
 opt record {
       record {
         Key;
         Trie_1;
       };
       List_1;
     };
type List = 
 opt record {
       record {
         Key_1;
         null;
       };
       List;
     };
type Level = 
 variant {
   hard;
   normal;
   simple;
   xhard;
 };
type Leaf_3 = 
 record {
   keyvals: AssocList_3;
   size: nat;
 };
type Leaf_2 = 
 record {
   keyvals: AssocList_2;
   size: nat;
 };
type Leaf_1 = 
 record {
   keyvals: AssocList_1;
   size: nat;
 };
type Leaf = 
 record {
   keyvals: AssocList;
   size: nat;
 };
type Key_1 = 
 record {
   hash: Hash;
   key: principal;
 };
type Key = 
 record {
   hash: Hash;
   key: text;
 };
type Image = 
 record {
   data: vec nat8;
   imageType: text;
 };
type HttpResponse = 
 record {
   body: blob;
   headers: vec HeaderField;
   status_code: nat16;
   streaming_strategy: opt StreamingStrategy;
   upgrade: opt bool;
 };
type HttpRequest = 
 record {
   body: blob;
   headers: vec HeaderField;
   method: text;
   url: text;
 };
type HttpHeader = 
 record {
   name: text;
   value: text;
 };
type HourlyMetricsData = 
 record {
   canisterCycles: CanisterCyclesAggregatedData;
   canisterHeapMemorySize: CanisterHeapMemoryAggregatedData;
   canisterMemorySize: CanisterMemoryAggregatedData;
   timeMillis: int;
   updateCalls: UpdateCallsAggregatedData;
 };
type HeaderField = 
 record {
   text;
   text;
 };
type Hash = nat32;
type GetMetricsParameters = 
 record {
   dateFromMillis: nat;
   dateToMillis: nat;
   granularity: MetricsGranularity;
 };
type GetLogMessagesParameters = 
 record {
   count: nat32;
   filter: opt GetLogMessagesFilter;
   fromTimeNanos: opt Nanos;
 };
type GetLogMessagesFilter = 
 record {
   analyzeCount: nat32;
   messageContains: opt text;
   messageRegex: opt text;
 };
type GetLatestLogMessagesParameters = 
 record {
   count: nat32;
   filter: opt GetLogMessagesFilter;
   upToTimeNanos: opt Nanos;
 };
type Event = 
 record {
   payload: principal;
   topic: text;
 };
type ENV = 
 record {
   auth_canister_id: principal;
   modclub_canister_id: principal;
   old_modclub_canister_id: principal;
   rs_canister_id: principal;
   vesting_canister_id: principal;
   wallet_canister_id: principal;
 };
type Decision__1 = 
 variant {
   approved;
   rejected;
 };
type Decision = 
 variant {
   approved;
   rejected;
 };
type DailyMetricsData = 
 record {
   canisterCycles: NumericEntity;
   canisterHeapMemorySize: NumericEntity;
   canisterMemorySize: NumericEntity;
   timeMillis: int;
   updateCalls: nat64;
 };
type ContentType = 
 variant {
   htmlContent;
   imageBlob;
   imageUrl;
   multiText;
   "text";
 };
type ContentStatus = 
 variant {
   approved;
   new;
   rejected;
 };
type ContentResult = 
 record {
   approvedCount: nat;
   rejectedCount: nat;
   sourceId: text;
   status: ContentStatus;
   violatedRules: vec ViolatedRules;
 };
type ContentPlus = 
 record {
   contentType: ContentType;
   createdAt: Timestamp;
   hasVoted: opt bool;
   id: ContentId;
   image: opt Image;
   minStake: nat;
   providerId: principal;
   providerName: text;
   receipt: Receipt;
   requiredVotes: nat;
   reservedList: vec Reserved;
   sourceId: text;
   status: ContentStatus;
   "text": opt text;
   title: opt text;
   updatedAt: Timestamp;
   voteCount: nat;
   voteParameters: VoteParameters;
 };
type ContentId = text;
type ConsumerPayload = 
 variant {
   admins: vec principal;
   events: vec Event;
 };
type Complexity = 
 record {
   expiryTime: Timestamp;
   level: Level;
 };
type ChallengeResponse = 
 record {
   challengeId: text;
   completedAt: opt int;
   requestedAt: opt int;
   status: PohChallengeStatus;
   submittedAt: opt int;
 };
type CanisterMetricsData = 
 variant {
   daily: vec DailyMetricsData;
   hourly: vec HourlyMetricsData;
 };
type CanisterMetrics = record {data: CanisterMetricsData;};
type CanisterMemoryAggregatedData = vec nat64;
type CanisterLogResponse = 
 variant {
   messages: CanisterLogMessages;
   messagesInfo: CanisterLogMessagesInfo;
 };
type CanisterLogRequest = 
 variant {
   getLatestMessages: GetLatestLogMessagesParameters;
   getMessages: GetLogMessagesParameters;
   getMessagesInfo;
 };
type CanisterLogMessagesInfo = 
 record {
   count: nat32;
   features: vec opt CanisterLogFeature;
   firstTimeNanos: opt Nanos;
   lastTimeNanos: opt Nanos;
 };
type CanisterLogMessages = 
 record {
   data: vec LogMessagesData;
   lastAnalyzedMessageTimeNanos: opt Nanos;
 };
type CanisterLogFeature = 
 variant {
   filterMessageByContains;
   filterMessageByRegex;
 };
type CanisterHttpResponsePayload = 
 record {
   body: vec nat8;
   headers: vec HttpHeader;
   status: nat;
 };
type CanisterHeapMemoryAggregatedData = vec nat64;
type CanisterCyclesAggregatedData = vec nat64;
type CanClaimLockedResponse = 
 record {
   canClaim: bool;
   claimAmount: Tokens;
   claimPrice: Tokens;
 };
type Branch_3 = 
 record {
   left: Trie_3;
   right: Trie_3;
   size: nat;
 };
type Branch_2 = 
 record {
   left: Trie_2;
   right: Trie_2;
   size: nat;
 };
type Branch_1 = 
 record {
   left: Trie_1;
   right: Trie_1;
   size: nat;
 };
type Branch = 
 record {
   left: Trie;
   right: Trie;
   size: nat;
 };
type AssocList_3 = 
 opt record {
       record {
         Key;
         null;
       };
       List_2;
     };
type AssocList_2 = 
 opt record {
       record {
         Key_1;
         Trie_3;
       };
       List_3;
     };
type AssocList_1 = 
 opt record {
       record {
         Key_1;
         null;
       };
       List;
     };
type AssocList = 
 opt record {
       record {
         Key;
         Trie_1;
       };
       List_1;
     };
type Activity = 
 record {
   contentType: ContentType;
   createdAt: Timestamp;
   minStake: nat;
   providerId: ProviderId;
   providerName: text;
   requiredVotes: nat;
   reward: float64;
   rewardRelease: Timestamp;
   status: ContentStatus;
   title: opt text;
   updatedAt: Timestamp;
   vote: Vote;
   voteCount: nat;
 };
type AccountsImportPayload = 
 record {
   adminsByProvider: vec ProviderAdmins;
   approvedPOHUsers: vec record {
                           principal;
                           principal;
                         };
   moderators: vec OldModeratorLeaderboard;
   providers: vec ProviderInfo;
 };
service : (ENV) -> ModClub
