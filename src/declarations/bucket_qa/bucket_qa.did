type UpdateCallsAggregatedData = vec nat64;
type StreamingStrategy = variant {
                           Callback:
                            record {
                              callback: StreamingCallback;
                              token: StreamingCallbackToken;
                            };};
type StreamingCallbackToken = 
 record {
   content_encoding: text;
   index: nat;
   key: text;
   sha256: opt vec nat8;
 };
type StreamingCallbackHttpResponse = 
 record {
   body: blob;
   token: opt StreamingCallbackToken;
 };
type StreamingCallback = func () -> ();
type NumericEntity = 
 record {
   avg: nat64;
   first: nat64;
   last: nat64;
   max: nat64;
   min: nat64;
 };
type Nanos = nat64;
type MetricsGranularity = 
 variant {
   daily;
   hourly;
 };
type LogMessagesData = 
 record {
   message: text;
   timeNanos: Nanos;
 };
type HttpResponse = 
 record {
   body: blob;
   headers: vec record {
                  text;
                  text;
                };
   status_code: nat16;
   streaming_strategy: opt StreamingStrategy;
 };
type HttpRequest = 
 record {
   body: blob;
   headers: vec record {
                  text;
                  text;
                };
   method: text;
   url: text;
 };
type HourlyMetricsData = 
 record {
   canisterCycles: CanisterCyclesAggregatedData;
   canisterHeapMemorySize: CanisterHeapMemoryAggregatedData;
   canisterMemorySize: CanisterMemoryAggregatedData;
   timeMillis: int;
   updateCalls: UpdateCallsAggregatedData;
 };
type GetMetricsParameters = 
 record {
   dateFromMillis: nat;
   dateToMillis: nat;
   granularity: MetricsGranularity;
 };
type GetLogMessagesParameters = 
 record {
   count: nat32;
   filter: opt GetLogMessagesFilter;
   fromTimeNanos: opt Nanos;
 };
type GetLogMessagesFilter = 
 record {
   analyzeCount: nat32;
   messageContains: opt text;
   messageRegex: opt text;
 };
type GetLatestLogMessagesParameters = 
 record {
   count: nat32;
   filter: opt GetLogMessagesFilter;
   upToTimeNanos: opt Nanos;
 };
type Event = 
 record {
   payload: principal;
   topic: text;
 };
type ENV = 
 record {
   auth_canister_id: principal;
   modclub_canister_id: principal;
   old_modclub_canister_id: principal;
   rs_canister_id: principal;
   vesting_canister_id: principal;
   wallet_canister_id: principal;
 };
type DailyMetricsData = 
 record {
   canisterCycles: NumericEntity;
   canisterHeapMemorySize: NumericEntity;
   canisterMemorySize: NumericEntity;
   timeMillis: int;
   updateCalls: nat64;
 };
type ContentInfo = 
 record {
   contentId: text;
   contentType: text;
   numOfChunks: nat;
 };
type ConsumerPayload = 
 variant {
   admins: vec principal;
   events: vec Event;
 };
type CanisterMetricsData = 
 variant {
   daily: vec DailyMetricsData;
   hourly: vec HourlyMetricsData;
 };
type CanisterMetrics = record {data: CanisterMetricsData;};
type CanisterMemoryAggregatedData = vec nat64;
type CanisterLogResponse = 
 variant {
   messages: CanisterLogMessages;
   messagesInfo: CanisterLogMessagesInfo;
 };
type CanisterLogRequest = 
 variant {
   getLatestMessages: GetLatestLogMessagesParameters;
   getMessages: GetLogMessagesParameters;
   getMessagesInfo;
 };
type CanisterLogMessagesInfo = 
 record {
   count: nat32;
   features: vec opt CanisterLogFeature;
   firstTimeNanos: opt Nanos;
   lastTimeNanos: opt Nanos;
 };
type CanisterLogMessages = 
 record {
   data: vec LogMessagesData;
   lastAnalyzedMessageTimeNanos: opt Nanos;
 };
type CanisterLogFeature = 
 variant {
   filterMessageByContains;
   filterMessageByRegex;
 };
type CanisterHeapMemoryAggregatedData = vec nat64;
type CanisterCyclesAggregatedData = vec nat64;
type Bucket = 
 service {
   collectCanisterMetrics: () -> ();
   deRegisterModerators: (vec principal) -> () oneway;
   getCanisterLog: (opt CanisterLogRequest) ->
    (opt CanisterLogResponse) query;
   getCanisterMetrics: (GetMetricsParameters) -> (opt CanisterMetrics) query;
   getChunk: (text, nat) -> (opt blob) query;
   getChunkData: () -> (vec text);
   getContentInfo: () -> (vec record {
                                text;
                                ContentInfo;
                              }) query;
   getFileInfoData: (text) -> (opt ContentInfo) query;
   getSize: () -> (nat);
   handleSubscription: (ConsumerPayload) -> ();
   http_request: (HttpRequest) -> (HttpResponse) query;
   markAllContentNotAccessible: () -> ();
   markContentAccessible: (text) -> ();
   markContentNotAccessible: (text) -> ();
   putChunks: (text, nat, blob, nat, text) -> (opt null);
   registerModerators: (vec principal) -> () oneway;
   runDeleteContentJob: () -> ();
   setParams: (vec principal, text) -> () oneway;
   setSigningKey: (text) -> ();
   showAdmins: () -> (vec principal) query;
   streamingCallback: (StreamingCallbackToken) ->
    (StreamingCallbackHttpResponse) query;
   subscribeOnAdmins: () -> ();
 };
service : (ENV) -> Bucket
