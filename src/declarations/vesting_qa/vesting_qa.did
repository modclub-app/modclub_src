type Vesting = 
 service {
   claim_staking: (Account, Tokens) -> (Result);
   claim_vesting: (Account, Tokens) -> (Result);
   claimed_stakes_for: (Account) -> (nat);
   collectCanisterMetrics: () -> ();
   getCanisterLog: (opt CanisterLogRequest) ->
    (opt CanisterLogResponse) query;
   getCanisterMetrics: (GetMetricsParameters) -> (opt CanisterMetrics) query;
   handleSubscription: (ConsumerPayload) -> ();
   locked_for: (Account) -> (nat);
   pending_stakes_for: (Account) -> (vec LockBlock);
   release_staking: (Account, Tokens) -> (Result);
   stage_vesting_block: (Account, Tokens) -> (Result);
   stake: (Account, Tokens) -> (Result);
   staked_for: (Account) -> (nat);
   unlock_staking: (Account, Tokens) -> (Result);
   unlocked_stakes_for: (Account) -> (nat);
   validate: (reserved) -> (Validate);
 };
type Validate = 
 variant {
   Err: text;
   Ok: text;
 };
type UpdateCallsAggregatedData = vec nat64;
type Tokens = nat;
type Subaccount = blob;
type Result = 
 variant {
   err: text;
   ok: nat;
 };
type Operation = 
 variant {
   StakingDissolve;
   StakingLock;
   StakingRelease;
   StakingUnlock;
   VestingClaim;
   VestingLock;
 };
type NumericEntity = 
 record {
   avg: nat64;
   first: nat64;
   last: nat64;
   max: nat64;
   min: nat64;
 };
type Nanos = nat64;
type MetricsGranularity = 
 variant {
   daily;
   hourly;
 };
type LogMessagesData = 
 record {
   message: text;
   timeNanos: Nanos;
 };
type LockBlock = 
 record {
   amount: nat;
   created_at_time: nat64;
   dissolveDelay: opt nat64;
   operation: Operation;
   rewardsAmount: opt nat;
 };
type HourlyMetricsData = 
 record {
   canisterCycles: CanisterCyclesAggregatedData;
   canisterHeapMemorySize: CanisterHeapMemoryAggregatedData;
   canisterMemorySize: CanisterMemoryAggregatedData;
   timeMillis: int;
   updateCalls: UpdateCallsAggregatedData;
 };
type GetMetricsParameters = 
 record {
   dateFromMillis: nat;
   dateToMillis: nat;
   granularity: MetricsGranularity;
 };
type GetLogMessagesParameters = 
 record {
   count: nat32;
   filter: opt GetLogMessagesFilter;
   fromTimeNanos: opt Nanos;
 };
type GetLogMessagesFilter = 
 record {
   analyzeCount: nat32;
   messageContains: opt text;
   messageRegex: opt text;
 };
type GetLatestLogMessagesParameters = 
 record {
   count: nat32;
   filter: opt GetLogMessagesFilter;
   upToTimeNanos: opt Nanos;
 };
type Event = 
 record {
   payload: principal;
   topic: text;
 };
type ENV = 
 record {
   auth_canister_id: principal;
   modclub_canister_id: principal;
   old_modclub_canister_id: principal;
   rs_canister_id: principal;
   vesting_canister_id: principal;
   wallet_canister_id: principal;
 };
type DailyMetricsData = 
 record {
   canisterCycles: NumericEntity;
   canisterHeapMemorySize: NumericEntity;
   canisterMemorySize: NumericEntity;
   timeMillis: int;
   updateCalls: nat64;
 };
type ConsumerPayload = 
 variant {
   admins: vec principal;
   events: vec Event;
 };
type CanisterMetricsData = 
 variant {
   daily: vec DailyMetricsData;
   hourly: vec HourlyMetricsData;
 };
type CanisterMetrics = record {data: CanisterMetricsData;};
type CanisterMemoryAggregatedData = vec nat64;
type CanisterLogResponse = 
 variant {
   messages: CanisterLogMessages;
   messagesInfo: CanisterLogMessagesInfo;
 };
type CanisterLogRequest = 
 variant {
   getLatestMessages: GetLatestLogMessagesParameters;
   getMessages: GetLogMessagesParameters;
   getMessagesInfo;
 };
type CanisterLogMessagesInfo = 
 record {
   count: nat32;
   features: vec opt CanisterLogFeature;
   firstTimeNanos: opt Nanos;
   lastTimeNanos: opt Nanos;
 };
type CanisterLogMessages = 
 record {
   data: vec LogMessagesData;
   lastAnalyzedMessageTimeNanos: opt Nanos;
 };
type CanisterLogFeature = 
 variant {
   filterMessageByContains;
   filterMessageByRegex;
 };
type CanisterHeapMemoryAggregatedData = vec nat64;
type CanisterCyclesAggregatedData = vec nat64;
type Account = 
 record {
   owner: principal;
   subaccount: opt Subaccount;
 };
service : (record {env: ENV;}) -> Vesting
